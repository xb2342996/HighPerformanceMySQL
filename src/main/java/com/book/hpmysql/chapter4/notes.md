# Schema与数据类型优化

## 选择优化的数据类型
MySQL支持非常多的数据类型，正确的选择数据类型对于获得高性能至关重要。下面几个原则有助于做出更好的选择：
- 更小的通常更好：一般情况下，应尽可能的使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为他们占用磁盘，内存和CPU缓存的空间更少，处理时需要的CPU周期更少。
- 简单就好：简单数据类型的操作通常需要更少的CPU周期。
- 尽量避免NULL：通常指定列为NOT NULL，除非真的需要存储Null值

在选择列数据类型时，第一步要确定合适的大类型：数字、字符串、时间等。

下一步选择具体类型。很多MySQL的数据类型可以存储相同类型的数据，只是存储长度与范围不一样，允许的精度不同，或者需要的物理空间不同。相同的大类型的不同子类型数据有时也有一些特殊的行为和属性。

### 整数类型
有两种类型的数字：整数和实数。如果存储整数，可以使用：tinyint，smallint，mediumint，int，bigint，分别使用8，16，32，64，128位存储空间。存储的值的范围从-2^(n-1) ~ 2^(n-1) - 1。

整数类型有可选的UNSIGNED属性，表示不允许负值，存储的值的范围提升一倍。

有符号与无符号类型使用相同的存储空间，并具有相同的性能。

MySQL可以指定整数类型的宽度，但对大多数应用都没有意义，它不会限制值的合法范围。

### 实数类型
实数是带小数部分的数字。然而他们不止为了存储小数部分；也可以使用decimal存储比bigint还大的整数。MySQL即支持精确类型，也支持非精确类型。

float和double类型支持使用标准的浮点运算进行近似计算。
decimal用于存储精确的小数，由于CPU不支持精确decimal的精确运算，MySQL服务器自身实现了decimal的高精度计算。

### 字符串类型
MySQL支持多种字符串类型，每种还有很多变种。每个字符串列可以定义自己的字符集和排序规则，或者说校验规则。

#### varchar和char
varchar类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为他们仅使用了必要的空间。varchar需要1个或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。

下面这些情况是用varchar是合适的：字符串列的最大长度比平均长度大很多，列的更新很少；使用了UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。

char类型是定长的：MySQL总是根据定义的字符串分配足够的空间。当存储char值时，MySQL会删除所有的末尾空格。

char适合存储很短的字符串，或者所有值都接近同一长度。定长的char不容易产生碎片。对于非常短的列，char比varchar在存储空间上更加效率。

#### blob和text
blob和text都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。他们分别属于两组不同的数据类型家族：字符类型是tinytext，smalltext，text，mediumtext，longtext；对应的二进制类型时tinyblob，smallblob，blob，mediumblob，longblob。

与其他类型不同，MySQL把每个blob和text值当做一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当blob和text的值太大时，innodb会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

#### 使用enum代替字符串类型
有时候可以使用枚举类代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或两个字节中。

### 日期与时间类型
MySQL可以使用许多类型来保存日期与时间值。MySQL能存储的最小时间粒度为秒。但是MySQL也可以使用微秒级的粒度进行临时运算。MySQL提供两种相似的日期类型：datetime与timestamp。

#### datetime
这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节存储空间。

#### timestamp
Timestamp类型保存了从1970年1月1日午夜以来的秒数，他和unix时间戳相同。timestamp只使用4个字节的存储空间，因此他的范围比datetime小得多。只能表示从1970年到2038年。Timestamp显示的值也依赖于时区。MySQL服务器，操作系统，以及客户端连接都有时区设置。

### 位数据类型
MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上讲都是字符串类型。

#### bit
可以使用bit列在一列中存储一个或多个true/false值。bit列的最大长度是64位。MySQL把bit当做字符串类型，而不是数字类型。对于大部分应用，最好避免使用bit类型。

#### set
如果需要保存多个true/false值，可以考虑合并这些列到一个set数据类型，他在MySQL内部以一系列打包的集合来表示的。

#### 在整数上进行按位操作
一种替代set的方式是使用证书包装一系列的位。比起set，这种方法主要的好处在于可以不适用alter table改变字段代表的枚举，缺点是查询语句更难写，

### 选择标识符
为标识列选择合适的数据类型非常重要。一般来说更有可能用标识列与其他值进行比较，或者通过标识列寻找其他列。选择标识列的类型时，不仅需要考虑存储类型，还需要考虑MySQL对这种类型如何执行排序与比较。

#### 整数类型
整数通常是标识列最好的选择，因为他们很快并可以使用auto_increment。
#### enum和set类型
对于标识列来说，enum和set类型通常是个比较糟糕的选择。
#### 字符串类型
如果可以的话尽量避免使用字符串作为标识列，因为他很消耗空间，并且通常比数字类型慢。对于完全随机的字符串，这些生产的新值会任意分布在很大的空间，这回导致insert以及一些select语句变慢。

## MySQL schema中的设计缺陷
- 太多的列：MySQL的存储引擎API工作时，需要在服务器层和存储引擎层之间进行缓冲格式拷贝数据，然后在服务器层将缓冲的内容解码成各个列。从行缓冲将编码过的列转换成行数据结构的操作代价非常高。
- 太多的关联：所谓的“实体-属性-值”（eav）的设计模式是一个常见的很糟糕的设计模式，MySQL限制了每个关联操作最多只能有61个表，但是在EAV数据库许多都是自关联的。如果希望查询执行的快且并发性好，单个查询最好在12个表以内做关联。
- 全能的枚举：防止过度使用枚举。
- 变相的枚举：枚举列允许在列中存储一组定义值中的单个值，集合列允许在列中存储一组定义的值中的一个或多个值。有时可能会造成混乱。
- 非此发明的NULL：当确实需要表示未知值时，不要害怕使用null。在一些场景中，null可能会比某个神奇的数字更好。

## 范式与反范式
### 范式的优点与缺点
+ 范式化的更新通常比反复范式化更快。
+ 当数据较好的范式化，就只有很少或者没有重复数据，所以只需要较少的修改数据。
+ 范式化的表通常很小，更好的存放在内存，所以执行操作会更快。
+ 很少有多余的数据意味着检索列表数据时，更少需要distinct或者group by语句。

范式的缺点通常需要关联，稍微复杂一点的查询语句在符合范式的schema上都可能需要至少一次关联，或许更多。这不但代价昂贵，而且会使索引失效。

### 反范式的优点与缺点
反范式的schema因为数据都在一张表，可以很好的避免关联问题。如果不需要关联表，则大部分查询最差的情况是全表扫描。当数据量比内存大的多的时候可能比关联要快得多，因为这样减少了随机I/O访问。

单独的表也能使用更有效的索引策略。

### 混合范式化与反范式化
在实际应用中经常混合使用，可能使用部分范式化的schema，缓存表，以及其他技巧。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。

## 缓存表与汇总表
有时提升性能最好的办法是在同一张表内保存衍生的冗余数据。有时需要创建一张完全独立的汇总表或缓存表。

使用缓存表和汇总表时，必须决定实时维护数据还是定期重建数据。哪个更好依赖于应用程序，但是定期重建并不只是节省资源，可以保证表不会有很多碎片，以及完全的顺序索引。

##加快alter table的速度
MySQL的alter table操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构的操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这种操作可能需要大量的时间，如果内存不足表又很大，而且还有很多索引的情况下尤其如此。

对于常见的场景，能使用的技巧只有2种：
- 先在一台不提供服务的机器上执行alter table，然后和提供服务的主库进行切换。
- 影子拷贝，影子拷贝的技巧是用要求的表结构创建一张和源表无关的表，然后通过重命名和删表操作交换两个表。


