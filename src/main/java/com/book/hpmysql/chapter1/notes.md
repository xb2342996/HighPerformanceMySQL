# MySQL架构与历史

## Mysql的逻辑架构
![avatar](../img/logic_framework.png)
3层结构：
1. 连接处理，授权认证，安全。
2. 核心服务功能，包括查询，分析，优化，缓存以及其他内置函数（例如时间，日期，数学函数等）。所有跨存储引擎的功能都在这一层实现。
3. 存储引擎，负责MySQL中数据的存储和提取。存储引擎不会去解析SQL（Innodb是个例外，它会解析外键定义，因为mysql服务器本身没有实现这个功能），不同的存储引擎之间也不会互相通信，只响应上层服务的请求。

### 连接管理与安全性
服务器缓存线程，减少频繁申请线程的开销。
<br>认证基于用户名，原始主机信息与密码，使用SSL连接还可以使用X.509证书认证。认证成功后会检测用户是否对库和表有操作权限。

### 执行与优化
MySQL会解析查询并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定读表顺序，以及选择合适的索引。

优化并不关心表使用了什么存储引擎，但是存储引擎对优化查询是有影响的。优化器会让引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息。

对于select解析查询之前，会先检查查询缓存，如果能在其中找到对应的查询，就不执行后续的操作，直接返回结果。

## 并发控制
只要多个查询同时修改数据，就会产生并发控制问题。MySQL在2个层面存在并发控制：服务器层和存储引擎层。

### 读写锁
解决这类问题的方法就是并发控制，其实非常简单。在处理并发读写时，可以实现由两种类型的锁组成的锁系统来解决问题。这个两个锁通常被称为共享锁和排他锁，也叫读锁和写锁。

读锁是共享的，或者说他互不阻塞，多个客户端可以同时读取通一个资源。写锁是排他的，也就是只有一个写锁会阻塞其他写锁的线程。只有这样才能保证同一时间内只有一个用户在执行写入，并防止其他用户读取正在写入的同一资源。

实际的数据库系统中，每时每刻都在发生锁定，当用户在修改某一部分数据时，MySQL会通过锁防止其他用户读取同一数据。大多数时候，MySQL锁的内部管理是透明的。

### 锁粒度
一种提高共享资源并发的方式是让锁定对象更具有选择性。尽量只锁定修改部分的数据，而不是所有资源。在给定的资源上，锁定的数据量越少，系统的并发程度越高，只要不相互冲突即可。

加锁也需要消耗资源，锁的各种操作，包括获得锁，检查锁和释放锁，都会增加系统开销，增加系统对锁的管理时间从而影响系统性能。

所谓锁策略就是在锁的开销和数据的安全性之间寻求平衡，这种平衡也会影响到性能。MySQL的每种存储引擎都可以实现自己的所策略和锁粒度。

#### 表锁
表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户对表进行操作之前首先要获取写锁，这回阻塞其他用户对该表的读写操作，只有没有写锁的情况下，其他用户才可以获取读锁，读锁之间互相不会阻塞。

#### 行级锁
行锁可以最大程度的支持并发处理，行锁只在存储引擎层实现，服务层完全不了解存储引擎中的锁实现。

## 事务
事务是一组原子性的SQL查询，或者一个独立的工作单元。如果数据库引擎能成功的对数据库应用该组查询的全部语句，那么就执行查询如果其中一条语句崩溃或者无法执行，那么所有语句都不会执行。事务内的语句要么全成功，要么全失败。

1. 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务要么全提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行事务的一部分操作。
2. 一致性：数据库总是从一个一致性状态转移到另一个一致性状态。
3. 隔离性：一个事物在提交之前，通常对其他事务是不可见的。
4. 持久性：一旦事务提交，则其修改的部分就会永久保存在数据库中。即使系统崩溃，修改的数据也不会丢失（物理崩溃除外）。

与锁粒度一样，这种事务的处理过程中的额外的安全性，同样也会增加系统额外的开销。一个实现了ACID的数据库，通常会需要更强的CPU，更大的内存和更多的磁盘空间。这也正是MySQL的存储引擎可以发挥优势的地方。用户可以根据自己的需求来选择是否需要事务处理，来选择合适的存储引擎。

### 隔离级别
在标准SQL中定义了四种隔离级别，每种都规定了一个事务中所做的修改。
READ UNCOMMITED 未提交读
<br>在未提交读级别，事务中的修改，即使没有提交，也会对其他事务可见。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。

READ COMMITED 提交读
<br>多数系统默认的隔离级别是提交读。READ COMMITED的隔离定义：只要一个事务开始时，只能看见已经提交过的事务所做的修改。一个事务在提交修改之前所做的任何操作都是不可见的。这个级别也叫做不可重复读（nonrepeatable read）。因为执行两次同样的查询，可能会的到不一样的结果。

REPEATABLE READ 可重复读
<br>可重复读解决了脏读的问题，该级别保证了在同一个事物中多次读取同样记录的结果是一致的。但是理论上可重复读隔离级别还是无法解决幻读的问题。所谓幻读，是指当某个事物在读取某个范围内的记录时，另一个事务又在该范围内插入了新的数据，当前事务再次读取时会产生幻行。

SERIALIZABLE 可串行化
可串行化是最高隔离级别，通过强制串行化事务，避免幻读的问题。只有在非常确保数据一致性且可以接受没有并发的情况下，才考虑该级别。

![avatar](../img/isolation_level.png)

### 死锁
死锁是指两个或者多个事务在同一资源上互相竞争，并请求锁定对方占用的资源。从而导致恶性循环。当多个事务以不同顺序锁定资源时，就会产生死锁。多个事务同时锁定同一个资源，也会产生死锁。

为了解决这个问题，数据库实现了各种死锁检测和死锁超时机制。一种解决方案是如果检测到死锁的循环依赖，并返回一个错误。另一种方法是当查询时间到达锁等待超时的设定后，放弃请求锁。InnoDB目前处理死锁的方式是将持有最少行级非排他锁的事务进行回滚。

锁的行为和顺序与存储引擎有关。以同样的顺序执行语句，有些引擎可能会产生死锁，有些则不会。死锁发生后只有完全或部分回滚一个事务，才能打破死锁。

### 事务日志
事务日志可以提高事务的效率。使用事务日志，存储引擎在修改表数据的时候只需要修改其内存拷贝，并将修改行为记录在持久在硬盘上的事务日志中。事务持久化之后，内存中被修改的数据在后台可以慢慢的写入到磁盘中。目前大多数存储引擎都是这样实现的，这种方式被称之为预写式日志（write-ahead log），修改数据需要些2次硬盘。

如果数据修改已经持久化到日志中，但是数据还没来得及写入到磁盘，系统崩溃，存储引擎在重启后能够自动恢复这部分数据。

### MySQL中的事务
MySQL提供2中事务型存储引擎：InnoDB和NDB Cluster

#### 自动提交
MySQL默认采用自动提交模式（AUTOCOMMIT）。也就是说，如果不是显式的开始一个事务，每一个查询都会被当做一个事务执行提交操作。

修改AUTOCOMMIT对非事务型的表，不会有任何影响。对这类表，没有ROLLBACK和COMMIT的概念，相当于一直处于autocommit的状态。

#### 在事务中混合使用存储引擎
MySQL服务器层不管理事务，事务由下层的存储引擎实现，所以在同一个事务中使用不同的存储引擎是不可靠的。

正常情况下混合使用没有什么问题，但是如果事务需要回滚，非事务型的表上的变更无法撤销，造成数据的不一致性。
<br>在非事务类型的表上执行事务相关操作，MySQL通常不会发出提示，也不会报错。

#### 隐式和显式锁定
Innodb采用的是二段锁定协议（two-phrase locking protocol）。在事务执行的过程中随时可以执行锁定，锁只有在执行COMMIT或ROLLBACK的时候才会释放，并且所有的锁都会在同一时刻释放。Innodb会根据隔离级别在需要的时候自动加锁。

> 除了事务中禁用了autocommit，可以使用lock tables之外，其他任何时候都不要显示的执行LOCK TABLES，不管使用什么存储引擎。

### 并发版本控制
基于并发性能的考虑，大多数事务型存储引擎都实现了多版本并发控制（Multi-Version Concurrency Control）。可以认为MVCC是行级锁的一个变种，但是他避免了加锁的操作。大多数都实现了非阻塞的读操作，写操作也只锁定必要的行。

InnoDB的MVCC是通过在每行记录中插入2个隐藏列来实现的。这个两个列一个保存了行的创建时间，一个保存了行的过期时间，存储的不是实际的时间，而是系统的版本号（System Version Number）。没开始一个新事物，系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

> Repeatable read隔离级别下，MVCC的具体操作：
> + Select
> <br>&emsp; InnoDB会根据一下两个条件检查每行记录：
>   1. Innodb只会查找版本早于当前版本的数据行，这样可以保证事务读取的行，要么是事务开始前已存在的，要么是事务自身插入或者修改过的
>   2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以保证事务读取到的行，在事务开始之前为被删除
> 
>   &emsp;只有符合上述2个条件的记录，才能返回作为查询结果。 
> + Insert
> <br>&emsp; InnoDB为插入的每一行保存当前系统版本号作为行版本号
> + DELETE
> <br>&emsp; InnoDB为删除的每一行保存当前系统版本号作为行删除标识
> + UPDATE 
> <br>&emsp; InnoDB为插入的一行，保存当前系统的版本号为行版本号，同时保存当前系统的版本号到原来的行作为行删除标识

保存这俩个额外的系统版本号，使大多数操作都可以不用加锁，这样设计使得读数据操作非常简单，性能很好，并且也能保证只会读到符合标准的行，不足之处是每行都需要额外的空间。MVCC只在Repeatable READ和read commited两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。

## MySQL的存储引擎
在文件系统中，MySQL将每个数据库保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的*.frm*文件保存表的定义。

### InnoDB存储引擎
InnoDB是MySQL中的默认事务型存储引擎，也是最重要，使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得他在非事务型存储的需求中也很流行。

Innodb的数据存储在表空间中，表空间是由Innodb管理的一个黑盒子，由一系列的数据文件组成。Innodb可以将每个表的数据和索引放在单独的文件中。

Innodb采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复度，并且通过锁间隙策略防止幻读的出现。锁间隙使得InnoDB不仅仅锁定查询所涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。

Innodb表是基于聚簇索引建立的。聚簇索引对主键查询有很高的性能，不过他的二级索引中必须包含主键列，所以如果主键列很大，其他的索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

Innodb内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够在内存中建立哈希索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。

作为事务型的存储引擎，Innodb通过一些机制与工具支持真正的支持热备份。MySQL的其他引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，在这种读写混合的场景，停止写入也意味着停止读取。

### MyISAM存储引擎
MySQL5.1以前的默认存储引擎，MyISAM提供了大量的特性，包括全文索引，压缩，GIS等，但MyISAM不支持事务和行锁，而且有一个非常严重的缺陷是崩溃后无法安全恢复。尽管MyISAM引擎不支持事务，不支持崩溃后的安全恢复，但是他依然有使用场景，对于只读的数据，或者表比较小、可以容忍修复的操作，依然可以使用MyISAM引擎。

MyISAM会将表存储在两个文件中：数据文件和索引文件，分别是.MYD和.MYI。MyISAM可以包含动态或者静态行。MySQL会根据表的定义来决定采用何种行格式。

MyISAM的特性：
1. 加锁与并发：MyISAM对整张表加锁，而不是针对行。读取时会对需要的读到的所有表加共享锁，写入时加排他锁。在表有读取查询的同时，也可以往表中插入新的记录。
2. 修复：对于MyISAM表，MySQL可以手工或自动执行检查和修复操作。执行表的修复可能会导致一些数据丢失，而且修复过程非常缓慢。
3. 索引特性：对于MyISAM表，即使是blob和text等长字段，也可以基于前500个字符创建索引。支持全文索引，可以支持复杂查询。
4. 延迟更新索引：创建MyISAM表时，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存的键缓冲区，只有在清理缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。

MyISAM压缩表
<br>如果表在创建并导入数据后，不会在对其进行修改操作，那么这种表适用MyISAM压缩表。压缩表是不能进行修改的，除非先将表解压，修改数据，再次压缩。压缩表可以极大地减少磁盘的空间，因此减少I/O操作，从而提升查询性能。

MyISAM性能
<br>MyISAM设计简单，数据格式紧密，在某些场景下性能很好。

### MySQL内建的其他存储引擎
+ Archive引擎
<br> 只支持insert与select操作。Archive引擎支持行级锁和专用的缓冲区，可以实现高并发的**插入**。在一个查询开始直到返回表中存在的所有行数之前，Archive引擎会阻止其他的Select执行，以实现读的一致性。另外，也实现了批量插入在完成前对读操作都是不可见的。
+ Blackhole引擎
<br> Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。这种特殊的存储引擎可以在一些特殊的复制框架和日志审核时发挥作用。
+ CSV引擎
<br> CSV引擎可以将普通的csv文件作为MySQL的表处理，但是这种表不支持索引。csv引擎可以在数据库运行时拷入或拷出文件。
+ Memory引擎
<br> 如果需要快速访问数据，并且这些数据不会修改，重启数据库后丢失也没关系，那么使用Memory表是非常有用的。Memory表比MyISAM快一个数量级，数据存储在内存中不需要去访问I/O。Memory表支持Hash索引，因此查找速度非常快。Memory表是表级锁，因此并发写入的性能较低
+ NDB集群引擎
<br> MySQL服务器，NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库组合，被称为MySQL集群。

### 选择合适的引擎
大部分情况下Innodb都是正确的选择，所以Oracle在MySQL5.5版本将它设置为默认的存储引擎。

除非万不得已，不建议混合使用多种存储引擎，否则会带来一系列复杂的问题，以及一些bug和潜在的边界问题。

如果应用需要不同的存储引擎，考虑以下几个因素：
1. 事务：如果应用需要事务支持，那么InnoDB是目前最稳定且经过验证的选择。如果不需要事务，那么MyISAM是个不错的选择。
2. 备份：如果定期关闭服务器来执行备份，那么备份因素可以忽略不计。反之，如果需要在线热备，Innodb就是最基本的要求。
3. 崩溃恢复：MyISAM崩溃后发生损坏的概率比Innodb要高的多，而且恢复速度缓慢，因此即便不需要事务，很多人也选择Innodb引擎。
4. 特有的特性：某些引擎可能依赖该引擎的特有特性或者优化

### 转换表的引擎
最简单的办法是直接使用alter table语句修改引擎，但是会有一个问题，需要执行很长的时间。MySQL会按照原表复制一张新的表，在复制期间可能会消耗系统所有的I/O能力，同时原表会上锁。

另一种办法是采用导入与导出的办法，手工对表进行复制。
为了更好的控制转换的过程，可以使用mysqldump工具将数据导出到文件，然后修改文件中的存储引擎选项。

第三种方法不需要导出整个数据表，而是先创建一个新的存储引擎表，然后利用insert select语句来导入数据。如果数据量很大可以分批处理，避免生成过多的undo。


